//*****************************************************************************
//
//! @file bus_hammer_test_cases.c
//!
//! @brief AXI stress test for various combinations of simultaneous traffic
//!
//!
//! AXI masters on Apollo5 are:
//!   GFX0: GPU source texture (read only)
//!   GFX1: GPU target (read-modify-write when blending)
//!   GFX2: GPU command list (CL) (read only)
//!   DISP: display framebuffer
//!   CM55: CPU access to any other AXI device (read/write)
//!   DMA: APBDMA transfer initiated by a peripheral (read/write)
//!
//! Each "target" is a set of target buffers for each of the AXI master traffic
//! generators.
//!
//! For SSRAM, there are 12 targets: 4 128k banks for each of the
//! SSRAM blocks. Due to unavoidable SSRAM usage by libraries like NemaGFX and
//! linker script restrictions, a 2MB stretch of SSRAM is reserved for the
//! SSRAM targets. This covers the last half (4 banks) of SSRAM0, the first half
//! of SSRAM2, and all of SSRAM1. For consistency, only the first half of SSRAM1
//! is used.
//!
//! For each MSPI device, two sets of pattern buffers are used: one 16K pattern
//! at address 0 used as the DMA source, and an XIP target at MSPI_TARGET_MEM_OFFSET
//! used as the target for any traffic type. For Apollo5, one device is PSRAM while
//! the other is flash as this is the least-common-denominator of the apollo5_eb
//! and apollo5(b)_fpga_turbo platforms. The flash device is initialized with
//! the correct patterns on global setup, and all operations, both DMA and XIP,
//! are limited to reads. The MSPI DMA workload alternates the MSPI device used
//! between flash and PSRAM to insure that the flash is always being read and the
//! PSRAM is always being written. This arrangement is necessary due to bug CAY-80
//! which prevents the same MSPI device from being used for DMA and XIP
//! simultaneously, and because the Turbo platform has only one MSPI PSRAM device.
//!
//! The MRAM target is a read-only pattern embedded in the application binary
//! aligned to 64k.
//!
//! The ROM target is a read-only target that depends on the contents of the boot
//! ROM. This target is used only for CM55 reads, and will vary depending on the
//! physical die rev or bootrom version. For FPGA platforms, where the boot ROM can
//! be in flux, the checksum for the pattern must be updated to match the current
//! FPGA.
//!
//! DCACHE is disabled as frequent clear/invalidate operations are required and
//! some spurious bugs (particularly writes from CM55 to SSRAM not always
//! going through) would take further work to debug. Disabling DCACHE does not
//! appear to affect throughput.
//!
//! The workloads are run through all permutations defined for each test case,
//! then those permutations repeated for a number of iterations defined in
//! bus_hammer_test_cases.h. Data transferred by each workload is verified
//! at the end of each permutation, and errors reported per test case through
//! Unity.
//!
//! This test launches four workloads to stress the 6 interfaces:
//!   issue_nemagfx_workload:
//!     Ping-pong texture blends between two buffers, clearing the destination
//!     before each blend. The command list for the workload is padded with
//!     NOPs so that GFX2 is thoroughly exercised as well as GFX0 and GFX1.
//!
//!     The flow for the GFX0/1 operations is clear gfx_buffer_B_SSRAM, blend
//!     gfx_buffer_A_SSRAM into gfx_buffer_B_SSRAM, then repeat with A and B
//!     swapped. This set of operations is repeated GFX_BLEND_CYCLES times,
//!     then the NOP padding at the end of the CL is processed. The blend
//!     operation is done in SIMPLE mode in RGBA8888, and with the alpha channel
//!     for the pattern set to 0xFF the GPU will read-modify-write each
//!     pixel at the destination yet will copy exact.
//!
//!     There is no way to verify errors on GFX2 other than a hang or failure to
//!     fully execute the CL. For GFX0 and GFX1, the RGBA8888 pattern in GFX0
//!     at the start of the test should verify exactly when the workload
//!     completes.
//!
//!     This workload is asynchronous, and completion is handled by an interrupt
//!     callback. However it appears that the GPU does not prefetch or
//!     otherwise read from the command list while prior operations on
//!     GFX0 or GFX1 are in flight. Therefore it is likely that the GPU will
//!     never be able to keep all 3 GFX ports busy at the same time.
//!
//!   issue_display_workload:
//!     Send fb_buffer_SSRAM to the display, exercising reads on the DISP master.
//!     This is asynchronous, with completion measured by an interrupt callback.
//!     Verifying the transfer requires measuring the CRC generated by the DC on
//!     sending a window to the display. For now, the CRC for a given buffer
//!     size and pattern is empirically determined by watching the SWO log
//!     messages and plugging the value into the DISP_CRC define.
//!
//!     For early Apollo5b FPGAs, a bug in a DPRAM implementation causes
//!     corruption of the framebuffer in flight, resulting in partial display
//!     updates and/or corrupted DC CRC.
//!
//!   issue_dma_workload:
//!     Transfers between an MSPI device and a target to generate traffic on
//!     the APBDMA port. At the moment the DMA operation queues a single read
//!     or write transaction asynchronously. To insure that we are generating
//!     both reads and writes, and to verify data integrity, this workload
//!     alternates between writing to PSRAM and reading on each call.
//!
//!     As mentioned above, MSPI-to-MSPI DMA transactions must alternate the
//!     source and destination between PSRAM (PSRAM_MSPI0) and flash (FLASH_MSPI1)
//!     to insure that writes don't go to the flash. It is the responsibility of
//!     the test case function to handle this. See mspi_hammer_test_cases for an
//!     example of how to do this properly.
//!
//!   CM55 workload:
//!     To generate read and write traffic on the CM55 port, the CM55 performs a
//!     pattern fill followed by a pattern verify. This is the only workload
//!     that is not asynchronous, and must be executed last to insure that CM55
//!     traffic is concurrent with the other AXI masters. Checksumming is used
//!     to verify traffic during the read phase of the CM55 workload to prevent
//!     accesses external to CM55 (i.e. memcmp against the definitive pattern in
//!     MRAM or storing the read data elsewhere). When the target is readonly,
//!     this workload skips the write phase and only performs a read-checksum.
//!     The rom_workload variant is nearly identical save for the checksum
//!     value and the base address of the target.
//!
//! Tests:
//!
//!     peak_ssram_test_cases:
//!         SSRAM0_BANK_A is used as the target for all workloads. This case
//!         is defined in CAYNSWS-927 and is an evolution of
//!         axi_master_stress_test_cases.
//!
//!     ssram_hammer_multi_block_single_bank_test_cases:
//!         Each worker uses the same target block and bank as in the peak
//!         test, but traffic is spread across all 3 SSRAMs by workload type.
//!         SSRAM0_BANK_A is used by CM55, SSRAM1_BANK_A is used by DMA and DISP,
//!         and SSRAM2_BANK_A is used by the 3 GFX ports. This case is defined in
//!         CAYNSWS-1306.
//!
//!     ssram_hammer_multi_block_multi_bank_test_cases:
//!         Tests one of 4096 permutations of SSRAM bank for each transfer
//!         type each iteration, eventually covering all possible combinations.
//!         Blocks remain the same for each type, using the same mapping as in
//!         ssram_hammer_multi_block_single_bank_test_cases. This case is defined
//!         in CAYNSWS-1306.
//!
//!     mspi_hammer_test_cases:
//!         Similar to peak_ssram_test_cases, except workers primarily use the
//!         target in MSPI0 PSRAM XIP. The exception is the DMA workload, which
//!         due to CAY-80 and board configuratoin, must alternate between PSRAM
//!         on MSPI0 and flash on MSPI1 depending on traffic direction. This
//!         case is defined in CAYNSWS-1307.
//!
//!     all_hammer_test_cases:
//!         Runs traffic intended to involve as many target devices as possible.
//!         The permutation patterns are derived from CAYNSWS-1308.
//!
//! Platform requirements:
//!   Either one of:
//!
//!     apollo5_eb with Peripheral Card 1. apollo5_eb should be in IOX mode 1, and
//!     the Peripheral Card 1 should be jumpered for DSI mode. If in the future
//!     the PSRAM on MSPI3 is used, then the IOX will need to be in mode 3.
//!
//!     Turbo FPGA platform. This should work for GSW images in IOX mode 1 or
//!     or DISP_MSPI_SDIO images in IOX mode 3. DISP_JDI_DSI_SDIO images have
//!     successfully been able to run this test, however the display does not
//!     show the RGB stripe pattern unless the apollo5b_fpga_turbo board config
//!     in ambiqsuite is updated for DSI and the Turbo mode jumpers changed to
//!     match.
//!
//! Results:
//!   Unity will report a pass unless an error is identified in launching a
//!   transfer or in verifying any of the expected patterns.
//!
//!   Periodically the test will print the average time elapsed for each
//!   workload and an overlap measurement for that iteration's workloads.
//!   The overlap is the number of microseconds during which all of the
//!   workloads are simultaneously executing.
//!
//!   If AM_DEBUG_PRINTF is defined, then the test will print
//!   the current targets for each permutation. This can be done to narrow down
//!   what traffic permutation is causing a hang.
//!
//!   A summary log is printed prior to returning the result to Unity displaying
//!   the approximate MB/s for each interface type. This measurement is based
//!   on all traffic types for an interface during the workload. See the header
//!   for the size computation for each type of workload.
//!
//*****************************************************************************

//*****************************************************************************
//
// ${copyright}
//
// This is part of revision ${version} of the AmbiqSuite Development Package.
//
//*****************************************************************************

#include "bus_hammer_test_cases.h"
#include "mspi.h"
#include "patterns.h"

typedef enum
{
    GPU_BURST_SIZE_16 = 4,
    GPU_BURST_SIZE_32 = 5,
    GPU_BURST_SIZE_64 = 6,
    GPU_BURST_SIZE_128 = 7,
} nemagfx_burst_size_t;

//*****************************************************************************
//
// Buffers
//
//*****************************************************************************

// Texture definitions
img_obj_t gfx_buffer_A_SSRAM = {{0}, TEX_RESX, TEX_RESY, TEX_RESX * 4, 0, NEMA_RGBA8888, 0};
img_obj_t gfx_buffer_B_SSRAM = {{0}, TEX_RESX, TEX_RESY, TEX_RESX * 4, 0, NEMA_RGBA8888, 0};
img_obj_t fb_buffer_SSRAM = {{0}, FB_RESX, FB_RESY, FB_RESX * 4, 0, NEMA_RGBA8888, 0};

// earmark SSRAM space
uint8_t SSRAMPool[SSRAM_POOL_SIZE] AM_SHARED_RW __attribute__ ((aligned(1024*512)));

//*****************************************************************************
//
// Globals
//
//*****************************************************************************

// Timing, statistics, and state for the current run. Global because some of the
// stop times are recorded in ISRs, and there's no overwhelming reason to move to
// a struct
volatile float g_fGFXStartTime = 0.f;
volatile float g_fGFXStopTime = 0.f;
volatile float g_fCM55StartTime = 0.f;
volatile float g_fCM55StopTime = 0.f;
volatile float g_fCM55TimeSpent = 0.f;
volatile float g_fROMStartTime = 0.f;
volatile float g_fROMStopTime = 0.f;
volatile float g_fROMTimeSpent = 0.f;
volatile float g_fDMAStartTime = 0.f;
volatile float g_fDMATimeSpent = 0.f;
volatile float g_fDispStartTime = 0.f;
volatile float g_fDispStopTime = 0.f;
volatile float g_fDispTimeSpent = 0.f;
volatile float g_fGFXTimeSpent = 0.f;
volatile float g_fOverlapTotal = 0.f;

volatile bool g_bGFXDone = false;
volatile bool g_bDispDone = false;
volatile bool g_bDMARead = false;
volatile int g_iIssuedCLID = -1;
uint32_t g_ui32ROMChecksum = 0;
uint32_t g_ui32CM55Checksum = 0;

//*****************************************************************************
//
//  Display init with centering of the FB
//
// based on tests/testcases/apollo5/nemagfx_tests/common/nemagfx_test_common.c
//
// ui16ResX: Framebuffer X dimension
// ui16ResY: Framebuffer Y dimension
//
//*****************************************************************************
uint32_t
dc_common_interface(uint16_t ui16ResX,uint16_t ui16ResY)
{
    uint16_t ui16MinX, ui16MinY;
    nemadc_initial_config_t sDCConfig;
    am_devices_dc_xspi_raydium_config_t sDisplayPanelConfig;
    uint32_t ui32MipiCfg = MIPICFG_16RGB888_OPT0;    //!< default config
    //
    // Set the display region to center
    //
    if (ui16ResX < g_sDispCfg.ui16ResX)
    {
        sDisplayPanelConfig.ui16ResX = ui16ResX;
    }
    else
    {
        sDisplayPanelConfig.ui16ResX = g_sDispCfg.ui16ResX;
    }
    ui16MinX = (g_sDispCfg.ui16ResX - sDisplayPanelConfig.ui16ResX) >> 1;
    ui16MinX = (ui16MinX >> 1) << 1;

    if (ui16ResY < g_sDispCfg.ui16ResY)
    {
        sDisplayPanelConfig.ui16ResY = ui16ResY;
    }
    else
    {
        sDisplayPanelConfig.ui16ResY = g_sDispCfg.ui16ResY;
    }
    ui16MinY = (g_sDispCfg.ui16ResY - sDisplayPanelConfig.ui16ResY) >> 1;
    ui16MinY = (ui16MinY >> 1) << 1;

    g_sDispCfg.eTEType = DISP_TE_DISABLE;
    sDCConfig.ui16ResX = sDisplayPanelConfig.ui16ResX;
    sDCConfig.ui16ResY = sDisplayPanelConfig.ui16ResY;
    sDCConfig.bTEEnable = (g_sDispCfg.eTEType == DISP_TE_DC);
    sDisplayPanelConfig.ui16MinX = ui16MinX + g_sDispCfg.ui16Offset;
    sDisplayPanelConfig.ui16MinY = ui16MinY;
    sDisplayPanelConfig.bTEEnable = (g_sDispCfg.eTEType != DISP_TE_DISABLE);
    sDisplayPanelConfig.bFlip = g_sDispCfg.bFlip;

    am_bsp_disp_pins_enable();

    if (g_sDispCfg.eInterface == DISP_IF_DSI)
    {
        //
        // VDD18 control callback function
        //
        am_hal_dsi_register_external_vdd18_callback(am_bsp_external_vdd18_switch);
        //
        // Enable DSI power and configure DSI clock.
        //
        am_hal_dsi_init();
    }
    else
    {
        am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_DISPCLKSEL_HFRC96, NULL);
        am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_DCCLK_ENABLE, NULL);
    }
    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_PERIPH_DISP);

    //
    //Initialize NemaDC
    //
    if (nemadc_init() != 0)
    {
        return -2;
    }

    if (g_sDispCfg.eInterface == DISP_IF_DSI)
    {
        uint8_t ui8LanesNum = g_sDispCfg.ui8NumLanes;
        uint8_t ui8DbiWidth = g_sDispCfg.eDbiWidth;
        uint32_t ui32FreqTrim = g_sDispCfg.eDsiFreq;
        pixel_format_t eFormat = FMT_RGB888;
        if (am_hal_dsi_para_config(ui8LanesNum, ui8DbiWidth, ui32FreqTrim, false) != 0)
        {
            return -3;
        }
        switch (eFormat)
        {
            case FMT_RGB888:
                if (ui8DbiWidth == 16)
                {
                    ui32MipiCfg = MIPICFG_16RGB888_OPT0;
                }
                if (ui8DbiWidth == 8)
                {
                    ui32MipiCfg = MIPICFG_8RGB888_OPT0;
                }
                break;

            case FMT_RGB565:
                if (ui8DbiWidth == 16)
                {
                    ui32MipiCfg = MIPICFG_16RGB565_OPT0;
                }
                if (ui8DbiWidth == 8)
                {
                    ui32MipiCfg = MIPICFG_8RGB565_OPT0;
                }
                break;

            default:
                //
                // invalid color component index
                //
                return -3;
        }
    }

    //
    // Initialize the display
    //
    switch (g_sDispCfg.eInterface)
    {
        case DISP_IF_SPI4:
            am_devices_dc_xspi_raydium_hardware_reset();
            sDCConfig.eInterface = DISP_INTERFACE_SPI4;
            sDCConfig.ui32PixelFormat = MIPICFG_1RGB888_OPT0;
            sDisplayPanelConfig.ui32PixelFormat = sDCConfig.ui32PixelFormat;
            nemadc_configure(&sDCConfig);
            am_devices_dc_xspi_raydium_init(&sDisplayPanelConfig);
            break;
        case DISP_IF_DSPI:
            am_devices_dc_xspi_raydium_hardware_reset();
            sDCConfig.eInterface = DISP_INTERFACE_DSPI;
            sDCConfig.ui32PixelFormat = MIPICFG_2RGB888_OPT0;
            sDisplayPanelConfig.ui32PixelFormat = sDCConfig.ui32PixelFormat;
            nemadc_configure(&sDCConfig);
            am_devices_dc_xspi_raydium_init(&sDisplayPanelConfig);

            break;
        case DISP_IF_QSPI:
            am_devices_dc_xspi_raydium_hardware_reset();
            sDCConfig.eInterface = DISP_INTERFACE_QSPI;
            sDCConfig.ui32PixelFormat = MIPICFG_4RGB888_OPT0;
            sDisplayPanelConfig.ui32PixelFormat = sDCConfig.ui32PixelFormat;
            nemadc_configure(&sDCConfig);
            am_devices_dc_xspi_raydium_init(&sDisplayPanelConfig);
            break;
        case DISP_IF_DSI:
            am_devices_dc_dsi_raydium_hardware_reset();
            sDCConfig.eInterface = DISP_INTERFACE_DBIDSI;
            sDCConfig.ui32PixelFormat = ui32MipiCfg;
            sDisplayPanelConfig.ui32PixelFormat = ui32MipiCfg;
            nemadc_configure(&sDCConfig);
            am_devices_dc_dsi_raydium_init(((am_devices_dc_dsi_raydium_config_t *) &sDisplayPanelConfig));
            break;
        default:
            ; //NOP
    }

    return 0;
}


//------------------------------------------------------------------------
//
//  Set GPU fb and texture burst sizes in the current command list
//
// fb_burst_size: one-hot framebuffer read burst size. See enums in nemagfx_burst_size_t
// tex_burst_size: one-hot texture read burst size. See enums in nemagfx_burst_size_t
//
//------------------------------------------------------------------------
void
set_nema_burst_size(nemagfx_burst_size_t fb_burst_size, nemagfx_burst_size_t tex_burst_size)
{
    uint32_t burst_size_reg_val = 0x0UL|((fb_burst_size)<<4)|(tex_burst_size);
    nema_cl_add_cmd(NEMA_BURST_SIZE, burst_size_reg_val);
}

//------------------------------------------------------------------------
//
//  Set the CPU and GPU performance mode
//
// mcu_mode: CPU performance mode. See am_hal_pwrctrl_mcu_mode_e for options
// gpu_mode: GPU performance mode. See am_hal_pwrctrl_gpu_mode_e for options
//
//------------------------------------------------------------------------
void
set_perf_mode(am_hal_pwrctrl_mcu_mode_e mcu_mode, am_hal_pwrctrl_gpu_mode_e gpu_mode)
{
    uint32_t ui32Status = am_hal_pwrctrl_mcu_mode_select(mcu_mode);
    if ( AM_HAL_STATUS_SUCCESS != ui32Status)
    {
        am_util_stdio_printf("CPU change power mode failed!\n");
        while(1){};
    }

    // disable GPU before power mode change
    am_hal_pwrctrl_periph_disable(AM_HAL_PWRCTRL_PERIPH_GFX);

    am_hal_pwrctrl_gpu_mode_e current_mode;
    am_hal_pwrctrl_gpu_mode_select(gpu_mode);
    am_hal_pwrctrl_gpu_mode_status(&current_mode);

    if(gpu_mode != current_mode)
    {
        am_util_stdio_printf("gpu switch power mode failed!\n");
        while(1){};
    }
    // reenable and reinit GPU after power mode change
    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_PERIPH_GFX);
    nema_init();
}

//*****************************************************************************
//
//  Log display transfer completion time on DC frame transfer end
//
//*****************************************************************************
void
disp_vsync_callback(void * pCallbackCtxt, uint32_t status)
{
    if(!g_bDispDone)
    {
        g_fDispStopTime = nema_get_time();
        g_bDispDone = true;
    }
}

//*****************************************************************************
//
//  Log GPU command list completion time on GFX CL completion
//
//*****************************************************************************
void gfx_callback(volatile int last_clid)
{
    if(!g_bGFXDone && (last_clid == g_iIssuedCLID))
    {
        g_fGFXStopTime = nema_get_time();
        g_bGFXDone = true;
    }
}

//*****************************************************************************
//
//  Prepare GPU command list
//
// Transfers textures from buffer_a_target to buffer_b_target and back again.
// If buffer_b_target is read-only, then the transfer from A to B will be skipped.
// Buffer A must not be read-only.
//
// After the CL is executed, buffer_a_target tex_a should be verified.
//
// *cl_target: target memory structure for storing the command list
// *buffer_a_target: target memory structure used for texture reads and writes. Must be
//    initalized with a test pattern before executing the CL if buffer_b is not 
//    read-only.
// *buffer_b_target: target memory structure used for texture reads and writes. Must
//    be initialized with a test pattern before executing the CL if read-only
//
//*****************************************************************************
void
setup_command_list(Target_t *cl_target, Target_t *buffer_a_target, Target_t *buffer_b_target)
{
    nema_buffer_t clbuffer;
    
    TEST_ASSERT_FALSE_MESSAGE(buffer_a_target->readonly, "buffer_a_target must be read-write!");

    clbuffer.base_phys = (uintptr_t)(cl_target->mem->cl);
    clbuffer.base_virt = (void*)(cl_target->mem->cl);
    clbuffer.size = CL_SIZE;
    clbuffer.fd = 0;

    // create a CL in the assigned memory
    cl_target->cl = nema_cl_create_prealloc(&clbuffer);
    TEST_ASSERT_EQUAL_UINT32_MESSAGE(nema_get_error(), NEMA_ERR_NO_ERROR, "NEMA error in prealloc");
    // set up the texture buffers

    nema_cl_bind(&(cl_target->cl));
    set_nema_burst_size(FB_BURST_SIZE, TEX_BURST_SIZE);

    for(int i=0; i<GFX_BLEND_CYCLES; i++)
    {
        if(!buffer_b_target->readonly)
        {
            // Copy from A->B using blitter
            nema_bind_dst_tex(buffer_b_target->gfx_buffer_b.bo.base_phys,
                                buffer_b_target->gfx_buffer_b.w,
                                buffer_b_target->gfx_buffer_b.h,
                                buffer_b_target->gfx_buffer_b.format,
                                buffer_b_target->gfx_buffer_b.stride);
            nema_bind_src_tex(buffer_a_target->gfx_buffer_a.bo.base_phys,
                                buffer_a_target->gfx_buffer_a.w,
                                buffer_a_target->gfx_buffer_a.h,
                                buffer_a_target->gfx_buffer_a.format,
                                buffer_a_target->gfx_buffer_a.stride,
                                NEMA_FILTER_PS);
            nema_clear(0x00000000); // clear destination w/ zeroed alpha
            nema_set_clip(0, 0, TEX_RESX, TEX_RESY);
            nema_set_blend_blit(NEMA_BL_SIMPLE);
            nema_blit(0, 0);
        }

        // Copy from B->A using blitter
        nema_bind_dst_tex(buffer_a_target->gfx_buffer_a.bo.base_phys,
                            buffer_a_target->gfx_buffer_a.w,
                            buffer_a_target->gfx_buffer_a.h,
                            buffer_a_target->gfx_buffer_a.format,
                            buffer_a_target->gfx_buffer_a.stride);
        nema_bind_src_tex(buffer_b_target->gfx_buffer_b.bo.base_phys,
                            buffer_b_target->gfx_buffer_b.w,
                            buffer_b_target->gfx_buffer_b.h,
                            buffer_b_target->gfx_buffer_b.format,
                            buffer_b_target->gfx_buffer_b.stride,
                            NEMA_FILTER_PS);
        nema_clear(0x00000000); // clear destination w/ zeroed alpha
        nema_set_clip(0, 0, TEX_RESX, TEX_RESY);
        nema_set_blend_blit(NEMA_BL_SIMPLE);
        nema_blit(0, 0);
    }
    // fill remainder of CL with NOPs
    // NOPs are about 8 bytes long
    uint32_t nops=0;
    for(int i=0;i<(CL_SIZE/8); i++)
    {
        if(nema_cl_almost_full(&(cl_target->cl)))
            break;
        nema_cl_add_cmd(CL_NOP, 0x0);
        TEST_ASSERT_EQUAL_UINT32_MESSAGE(nema_get_error(), NEMA_ERR_NO_ERROR, "NEMA error in NOP fill");
        nops++;
    }
    flush_cache_range((void*)cl_target->cl.bo.base_phys, cl_target->cl.bo.size);

    nema_cl_unbind();
}

//*****************************************************************************
//
//  Prefills the CM55, DMA, DISP, and GFX buffers with the test pattern
//
//  *target: Pointer to the target to be set up
//
//*****************************************************************************
void
setup_target(Target_t *target)
{
    if(!target->readonly)
    {
        // prefill the source buffer on the first iteration
        fill_pattern(target->gfx_buffer_a.bo.base_virt, target->gfx_buffer_a.bo.size, mram_target.tex_a);
        fill_pattern(target->fb_buffer.bo.base_virt, target->fb_buffer.bo.size,  mram_target.fb);
        fill_pattern(target->mem->dma, DMA_SIZE, mram_target.dma);

        // clear the CM55 buffer
        memset(target->mem->cm55, 0, CM55_SIZE);
        flush_cache_range((void*)(target->mem->cm55), CM55_SIZE);
    }
}

//*****************************************************************************
//
//  Set the target framebuffer memory that the DC sends to the display
//
//  *target: Pointer to the target structure to be used for the FB
//
//*****************************************************************************
void
set_dc_target(Target_t *target)
{
    //
    // send layer 0 to display via NemaDC
    //
    nemadc_layer_t layer0;
    layer0.resx          = FB_RESX;
    layer0.resy          = FB_RESY;
    layer0.buscfg        = 0;
    layer0.format        = NEMADC_RGBA8888;
    layer0.blendmode     = NEMADC_BL_SRC;
    layer0.stride        = layer0.resx * 4;
    layer0.startx        = 0;
    layer0.starty        = 0;
    layer0.sizex         = layer0.resx;
    layer0.sizey         = layer0.resy;
    layer0.alpha         = 0xff;
    layer0.flipx_en      = 0;
    layer0.flipy_en      = 0;
    layer0.baseaddr_virt = target->fb_buffer.bo.base_virt;
    layer0.baseaddr_phys = target->fb_buffer.bo.base_phys;

    nemadc_set_layer(0, &layer0); // This function includes layer enable.
}

void
globalSetUp(void)
{
    #ifdef ENABLE_UART_PRINTF
        // switch STDOUT to UART. For when I forget my external JLink
        am_bsp_uart_printf_enable();
    #endif

#if !USE_DCACHE
    am_hal_cachectrl_dcache_disable(); // disabled due to weird interaction between display and CM55 workloads
#endif
    set_perf_mode(AM_HAL_PWRCTRL_MCU_MODE_HIGH_PERFORMANCE, AM_HAL_PWRCTRL_GPU_MODE_HIGH_PERFORMANCE);
    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_PERIPH_GFX);

    //
    // Initialize NemaGFX
    //
    if(nema_init() != 0)
    {
        am_util_stdio_printf("GPU init failed!\n");
    }

    am_hal_interrupt_master_enable();
    setup_mspi((uint8_t*)&mram_target, sizeof(mram_target), (uint8_t*)(mram_target.dma), sizeof(mram_target.dma));

    g_ui32CM55Checksum = compute_checksum(mram_target.cm55, sizeof(mram_target.cm55));
    g_ui32ROMChecksum = compute_checksum(g_pui8ROM, ROM_READ_LENGTH);
    dc_common_interface(FB_RESX, FB_RESY);
}

void
globalTearDown(void)
{
    teardown_mspi();
}

void
setUp(void)
{
    nemagfx_set_interrupt_callback(gfx_callback);

    // initialize all targets. Note: does not initialize the CL!
    for(uint8_t i=0; i<NUM_TARGETS; i++)
    {
        setup_target(&(mem_targets[i]));
    }

    nemadc_set_vsync_interrupt_callback(disp_vsync_callback, NULL);

    // clear counters
    g_fCM55TimeSpent = 0.f;
    g_fDMATimeSpent = 0.f;
    g_fDispTimeSpent = 0.f;
    g_fGFXTimeSpent = 0.f;
    g_fOverlapTotal = 0.f;
}

void
tearDown(void)
{
}

//*****************************************************************************
//
//  Start DMA traffic, either a read or write to MSPI from SSRAM
//
// The global flag g_bDMARead is used to determine whether or not we are reading
// or writing. We alternate on each call so that we write first then read back to
// the same buffer in SSRAM. The caller is responsible for clearing the buffer
// before reading to insure that an aborted read doesn't pass the pattern verify
//
// *target: Target memory structure referencing the memory to use for DMA
//      transfers
// mspi: MSPI interface# for the DMA transaction
//
//*****************************************************************************
void
issue_dma_workload(Target_t *target, uint32_t mspi)
{
    uint32_t dma_stat;
    g_bDMADone = false;
#if USE_DCACHE
    AM_CRITICAL_BEGIN // guard was required when dcache enabled - prob because the TCB is in SSRAM
#endif
    if(g_bDMARead)
    {
        dma_stat = mspi_dma_read(mspi, target->mem->dma, 0x0, DMA_SIZE);
        g_bDMARead = false;
    }
    else
    {
        dma_stat = mspi_dma_write(mspi, target->mem->dma, 0x0, DMA_SIZE);
        g_bDMARead = true;
    }
    g_fDMAStartTime = nema_get_time();
#if USE_DCACHE
    AM_CRITICAL_END
#endif
    TEST_ASSERT_EQUAL_UINT32_MESSAGE(dma_stat, AM_DEVICES_MSPI_PSRAM_STATUS_SUCCESS, "DMA error during DMA transfer");
}

//*****************************************************************************
//
//  Send the display framebuffer to the display
//
// *target: Memory structure the DC will read from for updating the display
//
//*****************************************************************************
void
issue_display_workload(Target_t *target)
{
    g_bDispDone = false;
    set_dc_target(target);
    nemadc_transfer_frame_prepare(g_sDispCfg.eTEType != DISP_TE_DISABLE);
    if(g_sDispCfg.eTEType == DISP_TE_DISABLE)
    {
        //It's necessary to launch frame manually when TE is disabled.
        nemadc_transfer_frame_launch();
        g_fDispStartTime = nema_get_time();
    }
}

//*****************************************************************************
//
//  Launch nemagfx workload command list
//
// *target: Target memory structure containing the command list to execute
//
//*****************************************************************************
void
issue_nemagfx_workload(Target_t *target)
{
    g_bGFXDone = false;
    g_fGFXStartTime = nema_get_time();
    nema_cl_submit(&(target->cl));
    g_iIssuedCLID = target->cl.submission_id;
    TEST_ASSERT_EQUAL_UINT32_MESSAGE(nema_get_error(), NEMA_ERR_NO_ERROR, "NEMA error in submit");
}

//*****************************************************************************
//
//  Perform CM55 CPU workload
//
// Writes from the CPU to the target, then reads from the target to the CPU.
// Unlike the other issue_* functions, this is both blocking and self-verifying.
// If the target is read-only (i.e. flash, MRAM) then only the read-verify is
// performed and the target is expected to already have been initialized.
//
// *target: Target memory structure
//
//*****************************************************************************
void
run_cm55_workload(Target_t *target)
{
    g_fCM55StartTime = nema_get_time();
    if(!target->readonly)
    {
        write_cm55_mem_pattern(target->mem->cm55, CM55_SIZE);
    }
    TEST_ASSERT_EQUAL_UINT32_MESSAGE(g_ui32CM55Checksum,
        compute_checksum(target->mem->cm55, CM55_SIZE),
        "CM55 pattern compare failure");
    g_fCM55StopTime = nema_get_time();
}

//*****************************************************************************
//
//  Perform ROM workload
//
// Uses the CPU to read the ROM. create_rom_checksum() must have been previously
// called. Inherently blocking and self-verifying.
//
//*****************************************************************************
void
run_rom_workload()
{
    g_fROMStartTime = nema_get_time();
    TEST_ASSERT_EQUAL_UINT32_MESSAGE(g_ui32ROMChecksum,
        compute_checksum(g_pui8ROM, ROM_READ_LENGTH),
        "CM55<-ROM pattern compare failure");
    g_fROMStopTime = nema_get_time();
}

//*****************************************************************************
//
//  Calculate per-transfer statistics and print a periodic summary
//
// Computes the time spent per transfer type and overlap interval for each
// transfer, updates totals for later average calculation, and prints
// an update every LOG_INTERVAL transfers including the last computed DC CRC
//
// completed_transfers: Current count of completed transfers for the test
// nemadc_crc: 32-bit display controller CRC following the last display update
//
//*****************************************************************************
void
compute_xfer_statistics(uint32_t completed_transfers, uint32_t nemadc_crc)
{
    float stop_min, start_max, overlap;
    float gfx_avg, disp_avg, dma_avg, cm55_avg;

    // Calculate time spent per transfer
    g_fGFXTimeSpent += g_fGFXStopTime - g_fGFXStartTime;
    g_fDMATimeSpent += g_fDMAStopTime - g_fDMAStartTime;
    g_fDispTimeSpent += g_fDispStopTime - g_fDispStartTime;
    g_fCM55TimeSpent += g_fCM55StopTime - g_fCM55StartTime;

    // Calculate the interval that all transfers overlapped
    start_max = g_fGFXStartTime;
    stop_min = g_fGFXStopTime;

    if(g_fDMAStartTime > start_max)
    {
        start_max = g_fDMAStartTime;
    }
    if(g_fDispStartTime > start_max)
    {
        start_max = g_fDispStartTime;
    }
    if(g_fCM55StartTime > start_max)
    {
        start_max = g_fCM55StartTime;
    }
    if(g_fDMAStopTime < stop_min)
    {
        stop_min = g_fDMAStopTime;
    }
    if(g_fDispStopTime < stop_min)
    {
        stop_min = g_fDispStopTime;
    }
    if(g_fCM55StopTime < stop_min)
    {
        stop_min = g_fCM55StopTime;
    }

    overlap = stop_min - start_max;
    if(overlap < 0.f){
        overlap = 0;
    }

    g_fOverlapTotal += overlap;

    // print log message every LOG_INTERVAL transfers
    if((completed_transfers % LOG_INTERVAL) == 0)
    {
        disp_avg = (g_fDispTimeSpent / completed_transfers);
        dma_avg = (g_fDMATimeSpent / completed_transfers);
        gfx_avg = (g_fGFXTimeSpent / completed_transfers);
        cm55_avg = (g_fCM55TimeSpent / completed_transfers);

        am_util_stdio_printf("\n%6d:  DMA avg %4.3f us  GFX avg %4.3f us  CM55 avg %4.3f us  DISP avg: %4.3f us  overlap: %4.3f us  DC CRC: 0x%08x\n",
            completed_transfers,
            dma_avg * 1000000.0,
            gfx_avg * 1000000.0,
            cm55_avg * 1000000.0,
            disp_avg * 1000000.0,
            overlap * 1000000.0,
            nemadc_crc);
    }

}

//*****************************************************************************
//
//  Print a summary report at the end of the test
//
// Prints a summary of the average transfer time per transfer type, and
// the average of all overlap intervals
//
// completed_transfers: Current count of completed transfers for the test
//
//*****************************************************************************
void print_summary(uint32_t completed_transfers)
{
    float gfx_avg, disp_avg, dma_avg, cm55_avg, overlap_avg;
    disp_avg = (g_fDispTimeSpent / completed_transfers);
    dma_avg = (g_fDMATimeSpent / completed_transfers);
    gfx_avg = (g_fGFXTimeSpent / completed_transfers);
    cm55_avg = (g_fCM55TimeSpent / completed_transfers);
    overlap_avg = (g_fOverlapTotal / completed_transfers);

    // Test summary log
    am_util_stdio_printf("\nDMA: %.2f MB/s  GFX: %.2f MB/s  CM55: %.2f MB/s  DISP: %.2f MB/s  overlap avg: %4.3f us\n",
            DMA_SIZE / (dma_avg * (1024.0*1024.0)),
            GFX_BYTES_PER_ISSUE / (gfx_avg * (1024.0*1024.0)),
            (CM55_SIZE * 2) / (cm55_avg * (1024.0*1024.0)), // write then readback the buffer every iteration
            DISP_BYTES_PER_ISSUE / (disp_avg * (1024.0*1024.0)),
            overlap_avg * 1000000.0);
    am_util_stdio_printf("\n\n");
}

//*****************************************************************************
//
// Stress all AXI masters with defined permutations of targets
//
// This test reports measurements to SWO and not pass/fail.
//
// The permutations structure must be populated with pointers to arrays containing
// TargetTypes_t elements to be swept for each target type. This test case runner
// will step through all permutations of the target types listed in the elements.
// Each array must be terminated with "END_TARGETS".
//
// *permutations: TargetPermutations_t describing the test permutations to run
// loops: Number of times to step through all permutations.
//
// returns: bTestPass (always true)
//
//*****************************************************************************
bool
hammer_runner(TargetPermutations_t *permutations, uint32_t loops)
{
    bool bTestPass = true;
    uint32_t completed_transfers = 0;
    uint32_t nemadc_crc;

    uint8_t current_cm55_target = 0;
    uint8_t current_disp_target = 0;
    uint8_t current_dma_target = 0;
    uint8_t current_cl_target = 0;
    uint8_t current_tex_a_target = 0;
    uint8_t current_tex_b_target = 0;
    uint32_t loop_count = 0;

    g_bDMARead = false;
    while(loop_count < loops)
    {
        setup_command_list( &(mem_targets[permutations->cl_targets[current_cl_target]]),
                            &(mem_targets[permutations->tex_a_targets[current_tex_a_target]]),
                            &(mem_targets[permutations->tex_b_targets[current_tex_b_target]]));
        // prep
        if(g_bDMARead)
        {
            if(!mem_targets[permutations->dma_targets[current_dma_target]].readonly)
            {
                // clear DMA target on read
                memset(mem_targets[permutations->dma_targets[current_dma_target]].mem->dma, 0x00, DMA_SIZE);
                flush_cache_range((void*)(mem_targets[permutations->dma_targets[current_dma_target]].mem->dma), DMA_SIZE);
            }
        }
        else
        {
            if(mem_targets[permutations->dma_targets[current_dma_target]].readonly)
            {
                // for read only targets, we clear the DMA source buffer through XIP instead
                // before issuing a DMA write (from the current DMA target to the source
                // buffer)
                memset((uint8_t*)MSPI0_APERTURE_START_ADDR, 0x00, DMA_SIZE);
                flush_cache_range((void*)MSPI0_APERTURE_START_ADDR, DMA_SIZE);
            }
        }
        // skip operations if the DMA target is read-only as that's not supported
        if(!(mem_targets[permutations->dma_targets[current_dma_target]].readonly && g_bDMARead))
        {
            // print current permutation - requires AM_DEBUG_PRINTF defined
            // R/W: iteration using DMA read or write mode
            // Dnn: DMA TargetTypes_t enum
            // Cnn: CM55 TargetTypes_t enum
            // Pnn: Display TargetTypes_t enum
            // Lnn: GFX0 CL TargetTypes_t enum
            // Ann: GFX1 tex_a TargetTypes_t enum
            // Bnn: GFX2 tex_b TargetTypes_t enum
            am_util_debug_printf("%cD%02dC%02dP%02dL%02dA%02dB%02d ",
                g_bDMARead ? 'R':'W',
                permutations->dma_targets[current_dma_target],
                permutations->cm55_targets[current_cm55_target],
                permutations->disp_targets[current_disp_target],
                permutations->cl_targets[current_cl_target],
                permutations->tex_a_targets[current_tex_a_target],
                permutations->tex_b_targets[current_tex_b_target]);
            if(completed_transfers % 4 == 0)
            {
                am_util_debug_printf("\n");
            }

            // issue
            issue_nemagfx_workload(&(mem_targets[permutations->cl_targets[current_cl_target]]));
            issue_display_workload(&(mem_targets[permutations->disp_targets[current_disp_target]]));

            // DMA to MSPI0 PSRAM is a special case because we can't use the same device
            // as a DMA source and destination. To accommodate this, we use FLASH_MSPI1
            // and swap devices between reads and writes. See CAY-80
            if(permutations->dma_targets[current_dma_target] == PSRAM_MSPI0)
            {
                if(g_bDMARead)
                {
                    issue_dma_workload(&(mem_targets[permutations->dma_targets[current_dma_target]]), 1);
                }
                else
                {
                    issue_dma_workload(&(mem_targets[FLASH_MSPI1]), 0);
                }
            }
            else
            {
                // PSRAM_MSPI0 is not the target, business as usual
                issue_dma_workload(&(mem_targets[permutations->dma_targets[current_dma_target]]), 0);
            }

            //TODO: if we refactor so that we pass TargetTypes_t instead of the target object
            // as the workload parameters, then we can combine the ROM and CM55 workloads
            if(permutations->cm55_targets[current_cm55_target] == ROM)
            {
                run_rom_workload(&(mem_targets[permutations->cm55_targets[current_cm55_target]]));
            }
            else
            {
                run_cm55_workload(&(mem_targets[permutations->cm55_targets[current_cm55_target]]));
            }

            // wait for async workloads
            while(!g_bGFXDone || !g_bDispDone || !g_bDMADone)
            {
            }

            // verify
            nemadc_crc = nemadc_reg_read(NEMADC_REG_CRC);
            TEST_ASSERT_EQUAL_UINT32_MESSAGE(nemadc_crc, DISP_CRC, "Display CRC mismatch");

            verify_pattern(mem_targets[permutations->dma_targets[current_dma_target]].mem->tex_a,
                sizeof(mem_targets[PSRAM_MSPI0].mem->tex_a),
                mram_target.tex_a,
                "GFX");
            // note: g_bDMARead was inverted when we called issue_dma_workload()
            if(g_bDMARead || (!g_bDMARead && mem_targets[permutations->dma_targets[current_dma_target]].readonly))
            {
                // psram target for a write is at the base of the device
                verify_pattern((uint8_t*)(MSPI0_APERTURE_START_ADDR),
                    DMA_SIZE,
                    mram_target.dma,
                    "DMA");
            }
            else
            {
                // psram target for a read is in the TargetMem structure at MSPI0_START
                verify_pattern(mem_targets[permutations->dma_targets[current_dma_target]].mem->dma,
                    DMA_SIZE,
                    mram_target.dma,
                    "DMA");
            }
            completed_transfers++;
            compute_xfer_statistics(completed_transfers, nemadc_crc);
        }
        else
        {
            // we skipped because the DMA target is RO and we were on a read cycle,
            // so we need to advance to write
            g_bDMARead = false;
        }

        // select next permutation
        // When the DMA transfer flips back to write, then we advance DMA
        if(!g_bDMARead)
        {
            current_dma_target++;
        }
        if(permutations->dma_targets[current_dma_target] == END_TARGETS)
        {
            current_cm55_target++;
            current_dma_target = 0;
        }
        if(permutations->cm55_targets[current_cm55_target] == END_TARGETS)
        {
            current_disp_target++;
            current_cm55_target = 0;
        }
        if(permutations->disp_targets[current_disp_target] == END_TARGETS)
        {
            current_tex_a_target++;
            current_disp_target = 0;
        }
        if(permutations->tex_a_targets[current_tex_a_target] == END_TARGETS)
        {
            current_tex_b_target++;
            current_tex_a_target = 0;
        }
        if(permutations->tex_b_targets[current_tex_b_target] == END_TARGETS)
        {
            current_cl_target++;
            current_tex_b_target = 0;
        }
        if(permutations->cl_targets[current_cl_target] == END_TARGETS)
        {
            //roll over
            g_bDMARead = false;
            current_dma_target = 0;
            current_cm55_target = 0;
            current_disp_target = 0;
            current_cl_target = 0;
            current_tex_a_target = 0;
            current_tex_b_target = 0;
            loop_count++;
        }
    }

    // Test summary log
    print_summary(completed_transfers);
    return bTestPass;
} // hammer_runner

//*****************************************************************************
//
//! @brief Stress the AXI master ports on a single SSRAM bank
//!
//! This test reports measurements to SWO and not pass/fail.
//!
//! @return bTestPass (always true)
//
//*****************************************************************************
bool
peak_ssram_test_cases(void)
{
    am_util_stdio_printf("\n Peak SSRAM hammer test:\n\n");
#ifdef SKIP_PEAK_SSRAM_TEST_CASES
    return true;
#else
    TargetTypes_t cm55_targets[] =
    {
        SSRAM0_BANK_A,
        END_TARGETS
    };

    TargetTypes_t disp_targets[] =
    {
        SSRAM0_BANK_A,
        END_TARGETS
    };

    TargetTypes_t dma_targets[] =
    {
        SSRAM0_BANK_A,
        END_TARGETS
    };

    TargetTypes_t cl_targets[] =
    {
        SSRAM0_BANK_A,
        END_TARGETS
    };

    TargetTypes_t tex_a_targets[] =
    {
        SSRAM0_BANK_A,
        END_TARGETS
    };

    TargetTypes_t tex_b_targets[] =
    {
        SSRAM0_BANK_A,
        END_TARGETS
    };

    TargetPermutations_t permutations =
    {
        .cm55_targets = cm55_targets,
        .dma_targets = dma_targets,
        .disp_targets = disp_targets,
        .cl_targets = cl_targets,
        .tex_a_targets = tex_a_targets,
        .tex_b_targets = tex_b_targets
    };

    return hammer_runner(&permutations, PEAK_SSRAM_ITERATIONS);
#endif
}

//*****************************************************************************
//
//! @brief Stress the AXI master ports using all 3 SSRAMs but only one bank
//! per SSRAM
//!
//! This test reports measurements to SWO and not pass/fail.
//!
//! @return bTestPass (always true)
//
//*****************************************************************************
bool
ssram_hammer_multi_block_single_bank_test_cases(void)
{
    am_util_stdio_printf("\n SSRAM hammer multi block single bank test:\n\n");
#ifdef SKIP_SSRAM_HAMMER_MULTI_BLOCK_SINGLE_BANK_TEST_CASES
    return true;
#else
    TargetTypes_t cm55_targets[] =
    {
        SSRAM0_BANK_A,
        END_TARGETS
    };

    TargetTypes_t disp_targets[] =
    {
        SSRAM1_BANK_A,
        END_TARGETS
    };

    TargetTypes_t dma_targets[] =
    {
        SSRAM1_BANK_A,
        END_TARGETS
    };

    TargetTypes_t cl_targets[] =
    {
        SSRAM2_BANK_A,
        END_TARGETS
    };

    TargetTypes_t tex_a_targets[] =
    {
        SSRAM2_BANK_A,
        END_TARGETS
    };

    TargetTypes_t tex_b_targets[] =
    {
        SSRAM2_BANK_A,
        END_TARGETS
    };

    TargetPermutations_t permutations =
    {
        .cm55_targets = cm55_targets,
        .dma_targets = dma_targets,
        .disp_targets = disp_targets,
        .cl_targets = cl_targets,
        .tex_a_targets = tex_a_targets,
        .tex_b_targets = tex_b_targets
    };

    return hammer_runner(&permutations, SSRAM_HAMMER_MULTI_BLOCK_SINGLE_BANK_ITERATIONS);
    #endif
}

//*****************************************************************************
//
//! @brief Stress the AXI master ports using all 3 SSRAMs, testing all
//! permutations of the four available SSRAM banks on each test cycle
//!
//! This test reports measurements to SWO and not pass/fail.
//!
//! @return bTestPass (always true)
//
//*****************************************************************************
bool
ssram_hammer_multi_block_multi_bank_test_cases(void)
{
    am_util_stdio_printf("\n SSRAM hammer multi block multi bank test:\n\n");
#ifdef SKIP_SSRAM_HAMMER_MULTI_BLOCK_MULTI_BANK_TEST_CASES
    return true;
#else
    TargetTypes_t cm55_targets[] =
    {
        SSRAM0_BANK_A,
        SSRAM0_BANK_B,
        SSRAM0_BANK_C,
        SSRAM0_BANK_D,
        END_TARGETS
    };

    TargetTypes_t disp_targets[] =
    {
        SSRAM1_BANK_A,
        SSRAM1_BANK_B,
        SSRAM1_BANK_C,
        SSRAM1_BANK_D,
        END_TARGETS
    };
 
    TargetTypes_t dma_targets[] =
    {
        SSRAM1_BANK_A,
        SSRAM1_BANK_B,
        SSRAM1_BANK_C,
        SSRAM1_BANK_D,
        END_TARGETS
    };

    TargetTypes_t cl_targets[] =
    {
        SSRAM2_BANK_A,
        SSRAM2_BANK_B,
        SSRAM2_BANK_C,
        SSRAM2_BANK_D,
        END_TARGETS
    };

    TargetTypes_t tex_a_targets[] =
    {
        SSRAM2_BANK_A,
        SSRAM2_BANK_B,
        SSRAM2_BANK_C,
        SSRAM2_BANK_D,
        END_TARGETS
    };

    TargetTypes_t tex_b_targets[] =
    {
        SSRAM2_BANK_A,
        SSRAM2_BANK_B,
        SSRAM2_BANK_C,
        SSRAM2_BANK_D,
        END_TARGETS
    };

    TargetPermutations_t permutations =
    {
        .cm55_targets = cm55_targets,
        .dma_targets = dma_targets,
        .disp_targets = disp_targets,
        .cl_targets = cl_targets,
        .tex_a_targets = tex_a_targets,
        .tex_b_targets = tex_b_targets
    };

    return hammer_runner(&permutations, SSRAM_HAMMER_MULTI_BLOCK_MULTI_BANK_ITERATIONS);
    #endif
}

//*****************************************************************************
//
//! @brief Stress the AXI master ports using MSPI0 as the target. DMA targets
//!   MSPI0 when writing and MSPI1 when reading. This alternating behavior is
//!   due to Apollo5 (and 4) not supporting DMA to/from XIP hosted on the same
//!   device, and because the octal flash on MSPI1 is the only other available
//!   MSPI memory on the apollo5_fpga_turbo platform (and apollo5_eb also has
//!   an octal flash on MSPI1).
//!
//! This test reports measurements to SWO and not pass/fail.
//!
//! @return bTestPass (always true)
//
//*****************************************************************************
bool
mspi_hammer_test_cases(void)
{
    am_util_stdio_printf("\n MSPI hammer test:\n\n");
#ifdef SKIP_MSPI_HAMMER_TEST_CASES
    return true;
#else
    TargetTypes_t cm55_targets[] =
    {
        PSRAM_MSPI0,
        END_TARGETS
    };

    TargetTypes_t disp_targets[] =
    {
        PSRAM_MSPI0,
        END_TARGETS
    };

    TargetTypes_t dma_targets[] =
    {
        PSRAM_MSPI0,
        END_TARGETS
    };

    TargetTypes_t cl_targets[] =
    {
        PSRAM_MSPI0,
        END_TARGETS
    };

    TargetTypes_t tex_a_targets[] =
    {
        PSRAM_MSPI0,
        END_TARGETS
    };

    TargetTypes_t tex_b_targets[] =
    {
        PSRAM_MSPI0,
        END_TARGETS
    };

    TargetPermutations_t permutations =
    {
        .cm55_targets = cm55_targets,
        .dma_targets = dma_targets,
        .disp_targets = disp_targets,
        .cl_targets = cl_targets,
        .tex_a_targets = tex_a_targets,
        .tex_b_targets = tex_b_targets
    };

    return hammer_runner(&permutations, MSPI_HAMMER_ITERATIONS);
    #endif
}

//*****************************************************************************
//
//! @brief Stress all AXI masters with permutations of targets
//!
//! Run AXI master workloads in combinations defined by all possible permutations of
//! the arrays near the beginning of this function.
//!
//! This is based on CAYNSWS-1308. Currently GFX0 and GFX1 traffic to read-only targets
//! such as FLASH_MSPI1 and MRAM are not supported. See CAYNSWS-1308 for more detail.
//!
//! This test reports measurements to SWO and not pass/fail.
//!
//! @return bTestPass (always true)
//
//*****************************************************************************
bool
all_hammer_test_cases(void)
{
    am_util_stdio_printf("\n All hammer test:\n\n");
#ifdef SKIP_ALL_HAMMER_TEST_CASES
    return true;
#else
    TargetTypes_t cm55_targets[] =
    {
        MRAM,
        SSRAM0_BANK_A,
        PSRAM_MSPI0,
        FLASH_MSPI1,
        ROM,
        END_TARGETS
    };

    TargetTypes_t disp_targets[] =
    {
        MRAM,
        SSRAM1_BANK_A,
        PSRAM_MSPI0,
        FLASH_MSPI1,
        END_TARGETS
    };

    TargetTypes_t dma_targets[] =
    {
        SSRAM1_BANK_A,
        MRAM,
        TCM,
        PSRAM_MSPI0,
        FLASH_MSPI1,
        END_TARGETS
    };

    TargetTypes_t cl_targets[] =
    {
        SSRAM2_BANK_A,
        TCM,
        PSRAM_MSPI0,
        END_TARGETS
    };

    TargetTypes_t tex_a_targets[] =
    {
        SSRAM2_BANK_A,
        TCM,
        PSRAM_MSPI0,
        END_TARGETS
    };

    TargetTypes_t tex_b_targets[] =
    {
        SSRAM2_BANK_A,
        MRAM,
        TCM,
        PSRAM_MSPI0,
        FLASH_MSPI1,
        END_TARGETS
    };

    TargetPermutations_t permutations =
    {
        .cm55_targets = cm55_targets,
        .dma_targets = dma_targets,
        .disp_targets = disp_targets,
        .cl_targets = cl_targets,
        .tex_a_targets = tex_a_targets,
        .tex_b_targets = tex_b_targets
    };

    return hammer_runner(&permutations, ALL_HAMMER_ITERATIONS);
#endif
}