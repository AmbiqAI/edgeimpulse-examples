//*****************************************************************************
//
//! @file am_devices_tas2560.c
//!
//! @brief AP5 Audio Peripheral Card I2C AMP Driver
//!
//! @addtogroup tas2560 TAS2560 - AP5 Audio Peripheral Card I2C AMP Driver
//! @ingroup devices
//! @{
//
//**************************************************************************

//*****************************************************************************
//
// ${copyright}
//
// This is part of revision ${version} of the AmbiqSuite Development Package.
//
//*****************************************************************************
#include "am_devices_tas2560.h"
#include "am_bsp.h"
#include "string.h"
#include "am_util_delay.h"
#include "am_util_debug.h"
#include "am_util_stdio.h"

//*****************************************************************************
//
// Macro definitions.
//
//*****************************************************************************
#define CFG_META_SWITCH (255)
#define CFG_META_DELAY  (254)
#define CFG_META_BURST  (253)

#define TAS2560_MDELAY 0xFFFFFFFE
#define TAS2560_MSLEEP 0xFFFFFFFD
#define TAS2560_END    0xFFFFFFFF
/*
    Default registers configuration table. Generated by Ti PPC3 tool.
    Generation step:
    * Creat a TAS2560 project
    * Modify project parameters
        * Audio Mode Selection: ROM Mode 2
        * Device Control: Use default parameters
        * End System Integration
            * Sample Rate: 48KHz
            * Clock Source: BCLK
            * Clock Frequency: 1.536 MHz
            * Burst: 1
    * Dump to Output Window. This table will be shown in the Output Window.
*/
const static cfg_reg_t tas2560_def_params_table[] = {
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x07, 0x41},
    {CFG_META_DELAY, 0x10},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x07, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x01, 0x01},
    {CFG_META_DELAY, 0x10},

    {0x00, 0x00},
    {0x7f, 0x00},
    // Specify the clock (MCLK/BCLK)
    {0x0f, 0x01},
    // PLL P
    {0x0f, 0x01},
    // PLL J
    {0x10, 0x20},
    // PLL D - MSB 6 bits
    {0x11, 0x00},
    // PLL D - LSB 8 bits
    {0x12, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x00},
    // decimation and interpolation
    {0x0d, 0x08},
    {0x0e, 0x10},
    // clock error detection
    {0x50, 0x31},
    {0x04, 0x5f},
    {0x15, 0x02},
    {0x09, 0x83},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0xfd},
    {0x36, 0xc0},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x08, 0x01},
    {0x36, 0x32},
    {0x22, 0x3f},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x49, 0x0c},
    {0x3c, 0x33},
    {0x02, 0x02},
    {0x07, 0x41},
    {CFG_META_DELAY, 0x10},
    {0x00, 0x32},
    {0x28, 0x7f},
    {0x29, 0xfb},
    {0x2a, 0xb5},
    {0x2b, 0x00},
    {0x2c, 0x80},
    {0x2d, 0x04},
    {0x2e, 0x4c},
    {0x2f, 0x00},
    {0x30, 0x7f},
    {0x31, 0xf7},
    {0x32, 0x6a},
    {0x33, 0x00},
    {0x1c, 0x7f},
    {0x1d, 0xff},
    {0x1e, 0xff},
    {0x1f, 0xff},
    {0x20, 0x00},
    {0x21, 0x00},
    {0x22, 0x00},
    {0x23, 0x00},
    {0x24, 0x00},
    {0x25, 0x00},
    {0x26, 0x00},
    {0x27, 0x00},
    {0x00, 0x33},
    {0x18, 0x06},
    {0x19, 0x66},
    {0x1a, 0x66},
    {0x1b, 0x66},
    {0x00, 0x34},
    {0x34, 0x3a},
    {0x35, 0x46},
    {0x36, 0x74},
    {0x37, 0x00},
    {0x38, 0x22},
    {0x39, 0xf3},
    {0x3a, 0x07},
    {0x3b, 0x00},
    {0x3c, 0x80},
    {0x3d, 0x77},
    {0x3e, 0x61},
    {0x3f, 0x00},
    {0x40, 0x22},
    {0x41, 0xa7},
    {0x42, 0xcc},
    {0x43, 0x00},
    {0x44, 0x3a},
    {0x45, 0x0c},
    {0x46, 0x93},
    {0x47, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x33},
    {0x10, 0x75},
    {0x11, 0xc2},
    {0x12, 0x8e},
    {0x13, 0x00},
    // Left justifying format, 16bit
    {0x14, 0x6c},
    {0x15, 0x14},
    {0x16, 0x79},
    {0x17, 0x00},
    {0x20, 0x1e},
    {0x21, 0x00},
    {0x22, 0x00},
    {0x23, 0x00},
    {0x24, 0x21},
    {0x25, 0x3d},
    {0x26, 0x71},
    {0x27, 0x00},
    {0x28, 0x24},
    {0x29, 0x7a},
    {0x2a, 0xe1},
    {0x2b, 0x00},
    {0x2c, 0x27},
    {0x2d, 0xb8},
    {0x2e, 0x52},
    {0x2f, 0x00},
    {0x30, 0x2a},
    {0x31, 0xf5},
    {0x32, 0xc3},
    {0x33, 0x00},
    {0x34, 0x2e},
    {0x35, 0x33},
    {0x36, 0x33},
    {0x37, 0x00},
    {0x38, 0x31},
    {0x39, 0x70},
    {0x3a, 0xa4},
    {0x3b, 0x00},
    {0x3c, 0x34},
    {0x3d, 0xae},
    {0x3e, 0x14},
    {0x3f, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x32},
    {0x3c, 0x3d},
    {0x3d, 0x99},
    {0x3e, 0x9a},
    {0x3f, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x32},
    {0x40, 0x30},
    {0x41, 0x00},
    {0x42, 0x00},
    {0x43, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x32},
    {0x44, 0x50},
    {0x45, 0x00},
    {0x46, 0x00},
    {0x47, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x32},
    {0x4c, 0x02},
    {0x4d, 0x00},
    {0x4e, 0x00},
    {0x4f, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x32},
    {0x54, 0x00},
    {0x55, 0x88},
    {0x56, 0x40},
    {0x57, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x32},
    {0x58, 0x00},
    {0x59, 0x06},
    {0x5a, 0xd3},
    {0x5b, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x32},
    {0x60, 0x28},
    {0x61, 0x00},
    {0x62, 0x00},
    {0x63, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x33},
    {0x40, 0x00},
    {0x41, 0x00},
    {0x42, 0x00},
    {0x43, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    {0x00, 0x33},
    {0x64, 0x39},
    {0x65, 0x80},
    {0x66, 0x00},
    {0x67, 0x00},
    {0x00, 0x00},
    {0x7f, 0x00},
    // Mute
    {0x07, 0x41},
};

// TAS2560 sample rate 48000
const static uint32_t p_tas2560_48khz_data[] = {
    /* reg address    size  values */

    // ClassD Ramp control
    TAS2560_SR_CTRL1, 0x01, 0x01,
    // DAC interpolation ration outside DSP
    TAS2560_SR_CTRL2, 0x01, 0x08,
    // ADC decimation ratio outside DSP
    TAS2560_SR_CTRL3, 0x01, 0x10,
    // The end of data
    TAS2560_END, TAS2560_END};

// TAS2560 sample rate 44100
const static uint32_t p_tas2560_441khz_data[] = {
    /* reg address    size  values */
    // ClassD Ramp control
    TAS2560_SR_CTRL1, 0x01, 0x11,
    // The end of data
    TAS2560_END, TAS2560_END};

// TAS2560 sample rate 16000
const static uint32_t p_tas2560_16khz_data[] = {
    /* reg address    size  values */

    // ClassD Ramp control
    TAS2560_SR_CTRL1, 0x01, 0x01,
    // DAC interpolation ration outside DSP
    TAS2560_SR_CTRL2, 0x01, 0x18,
    // ADC decimation ratio outside DSP
    TAS2560_SR_CTRL3, 0x01, 0x20,
    // The end of data
    TAS2560_END, TAS2560_END};

// TAS2560 sample rate 8000
const static uint32_t p_tas2560_8khz_data[] = {
    /* reg address    size  values */

    // ClassD Ramp control
    TAS2560_SR_CTRL1, 0x01, 0x01,
    // DAC interpolation ration outside DSP
    TAS2560_SR_CTRL2, 0x01, 0x30,
    // ADC decimation ratio outside DSP
    TAS2560_SR_CTRL3, 0x01, 0x20,
    // The end of data
    TAS2560_END, TAS2560_END};

// TAS2560 unmute
const static uint32_t p_tas2560_unmute_data[] = {
    /* reg address    size  values */

    // Unmute
    TAS2560_MUTE_REG, 0x01, 0x40,
    // delay 20ms
    TAS2560_MDELAY, 0x01, 20,
    // The end of data
    TAS2560_END, TAS2560_END};

// TAS2560 mute
const static uint32_t p_tas2560_mute_data[] = {
    /* reg address    size  values    */

    // Mute
    TAS2560_MUTE_REG, 0x01, 0x01,
    // delay 20ms
    TAS2560_MDELAY, 0x01, 20,
    // The end of data
    TAS2560_END, TAS2560_END};

//*****************************************************************************
//
// Static variables.
//
//*****************************************************************************
static void *g_tas2560_IOMHandle = NULL;

//*****************************************************************************
//
// Local functions public.
//
//*****************************************************************************
static uint32_t tas2560_i2c_read(uint32_t i2c_dev_addr, uint32_t *p_buf,
                                 uint32_t size);
static uint32_t tas2560_i2c_write(uint32_t i2c_dev_addr, uint32_t *p_buf,
                                  uint32_t size);
static uint32_t tas2560_master_xfer(i2c_msg_t *msgs);

//*****************************************************************************
//
//! @brief Write data to TAS2560 register
//!
//! @param chip_addr Chip address.
//! @param reg_addr Register address.
//! @param buffer Pointer of buffer.
//! @param length The length of buffer.
//!
//! @return status - Generic or interface specific status.
//
//*****************************************************************************
static uint32_t tas2560_write(uint8_t chip_addr, uint8_t reg_addr,
                              const uint8_t *buffer, uint16_t length)
{
    if (buffer == NULL)
    {
        return AM_DEVICES_TAS2560_STATUS_FAIL;
    }

    uint8_t send_buffer[sizeof(reg_addr) + 32 + length];
    send_buffer[0] = reg_addr; // register address
    memcpy(send_buffer + 1, buffer, length);

    i2c_msg_t msgs[] =
    {
      {
        .addr  = chip_addr,
        .flags = AM_DEVICES_TAS2560_I2C_WR,
        .len   = length + sizeof(reg_addr),
        .buf   = send_buffer,
      }
    };

    return tas2560_master_xfer(msgs);
}

//*****************************************************************************
//
//! @brief Read data from TAS2560.
//!
//! @param i2c_dev_addr Chip I2C device address.
//! @param p_buf The pointer of buffer.
//! @param size The size of buffer.
//!
//! @return status - Generic or interface specific status.
//
//*****************************************************************************
static uint32_t tas2560_i2c_read(uint32_t i2c_dev_addr, uint32_t *p_buf,
                                 uint32_t size)
{
    am_hal_iom_transfer_t Transaction;

    Transaction.ui8Priority        = 1;
    Transaction.ui32InstrLen       = 0;
    Transaction.ui64Instr          = 0;
    Transaction.eDirection         = AM_HAL_IOM_RX;
    Transaction.ui32NumBytes       = size;
    Transaction.pui32RxBuffer      = p_buf;
    Transaction.bContinue          = false;
    Transaction.ui8RepeatCount     = 0;
    Transaction.ui32PauseCondition = 0;
    Transaction.ui32StatusSetClr   = 0;

    Transaction.uPeerInfo.ui32I2CDevAddr = i2c_dev_addr;
    if (am_hal_iom_blocking_transfer(g_tas2560_IOMHandle, &Transaction) !=
        AM_HAL_STATUS_SUCCESS)
    {
        return AM_DEVICES_TAS2560_STATUS_INVALID_OPERATION;
    }

    return AM_DEVICES_TAS2560_STATUS_SUCCESS;
}

//*****************************************************************************
//
//! @brief Write data to TAS2560
//!
//! @param i2c_dev_addr Chip I2C device address.
//! @param p_buf The pointer of buffer.
//! @param size The size of buffer.
//!
//! @return status - Generic or interface specific status.
//
//*****************************************************************************
static uint32_t tas2560_i2c_write(uint32_t i2c_dev_addr, uint32_t *p_buf,
                                  uint32_t size)
{
    am_hal_iom_transfer_t Transaction;

    Transaction.ui8Priority        = 1;
    Transaction.ui32InstrLen       = 0;
    Transaction.ui64Instr          = 0;
    Transaction.eDirection         = AM_HAL_IOM_TX;
    Transaction.ui32NumBytes       = size;
    Transaction.pui32TxBuffer      = p_buf;
    Transaction.bContinue          = false;
    Transaction.ui8RepeatCount     = 0;
    Transaction.ui32PauseCondition = 0;
    Transaction.ui32StatusSetClr   = 0;

    Transaction.uPeerInfo.ui32I2CDevAddr = i2c_dev_addr;
    if (am_hal_iom_blocking_transfer(g_tas2560_IOMHandle, &Transaction) !=
        AM_HAL_STATUS_SUCCESS)
    {
        return AM_DEVICES_TAS2560_STATUS_INVALID_OPERATION;
    }

    return AM_DEVICES_TAS2560_STATUS_SUCCESS;
}

//*****************************************************************************
//
//! @brief Transfer data to/from TAS2560 via I2C
//!
//! @param msg The pointer of i2c message
//!
//! @return status - Generic or interface specific status.
//
//*****************************************************************************
static uint32_t tas2560_master_xfer(i2c_msg_t *msg)
{
    uint32_t status = AM_DEVICES_TAS2560_STATUS_SUCCESS;

    if (msg->flags == AM_DEVICES_TAS2560_I2C_RD)
    {
        status = tas2560_i2c_read(msg->addr, (uint32_t *)msg->buf, msg->len);
    }
    else if (msg->flags == AM_DEVICES_TAS2560_I2C_WR)
    {
        status = tas2560_i2c_write(msg->addr, (uint32_t *)msg->buf, msg->len);
    }

    return status;
}

// ****************************************************************************
//
//! @brief Initialize the TAS2560 by writing the default parameters,
//!
//! @param reg The pointer of default register table.
//! @param number The number of register table line.
//!
//! @return status - Generic or interface specific status.
//
// ****************************************************************************
static uint32_t tas2560_init_def_params(uint8_t chip_addr, const cfg_reg_t *reg,
                                        uint32_t number)
{
    uint32_t status = AM_DEVICES_TAS2560_STATUS_SUCCESS;
    uint32_t i      = 0;
    while (i < number)
    {
        switch (reg[i].command)
        {
            case CFG_META_SWITCH:
                // Used in legacy applications.  Ignored here.
                break;
            case CFG_META_DELAY:
                am_util_delay_ms(reg[i].param);
                break;
            case CFG_META_BURST:
                // The register is written continuously.
                status = tas2560_write(chip_addr, reg[i + 1].command,
                                       &(reg[i + 1].param), reg[i].param);
                i += (reg[i].param / 2) + 1;
                if (status != AM_DEVICES_TAS2560_STATUS_SUCCESS)
                {
                    return status;
                }
                break;
            default:
                status = tas2560_write(chip_addr, reg[i].command, &(reg[i].param),
                                       sizeof(reg[i].param));
                if (status != AM_DEVICES_TAS2560_STATUS_SUCCESS)
                {
                    return status;
                }
                break;
        }
        i++;
    }

    return status;
}

// ****************************************************************************
//
//! @brief Change the register in the book and page
//!
//! @param book The ID of book.
//! @param page The ID of page.
//!
//! @return status - Generic or interface specific status.
//
// ****************************************************************************
static uint32_t tas2560_change_book_page(uint8_t chip_addr, uint8_t book,
                                         uint8_t page)
{
    uint32_t status = AM_DEVICES_TAS2560_STATUS_SUCCESS;
    uint8_t  buf[1] = {0};

    // Must change to page 0 of current book before changing book
    buf[0] = 0;
    status = tas2560_write(chip_addr, TAS2560_BOOKCTL_PAGE, buf, sizeof(buf));
    if (status != AM_DEVICES_TAS2560_STATUS_SUCCESS)
    {
        return status;
    }

    // 0X7F is the specified flag of book.
    // Change book.
    buf[0] = book;
    status = tas2560_write(chip_addr, TAS2560_BOOKCTL_REG, buf, sizeof(buf));
    if (status != AM_DEVICES_TAS2560_STATUS_SUCCESS)
    {
        return status;
    }

    // Change page.
    buf[0] = page;
    status = tas2560_write(chip_addr, TAS2560_BOOKCTL_PAGE, buf, sizeof(buf));

    return status;
}

// ****************************************************************************
//
//! @brief Change the book and page, then write register value
//!
//! @param chip_addr The chip I2C device address.
//! @param reg The fusion value of book, page, register.
//! @param p_data The point of data.
//! @param len The length of data.
//!
//! @return status - Generic or interface specific status.
//
// ****************************************************************************
static uint32_t tas2560_bulk_write(uint8_t chip_addr, uint32_t reg,
                                   uint8_t *p_data, uint32_t len)
{
    uint32_t status = AM_DEVICES_TAS2560_STATUS_SUCCESS;

    status = tas2560_change_book_page(chip_addr, TAS2560_BOOK_ID(reg),
                                      TAS2560_PAGE_ID(reg));
    if (status != AM_DEVICES_TAS2560_STATUS_SUCCESS)
    {
        return status;
    }

    status = tas2560_write(chip_addr, TAS2560_PAGE_REG(reg), p_data, len);

    return status;
}

// ****************************************************************************
//
//! @brief Load large chunks of data.
//!
//! @param chip_addr The chip I2C device address.
//! @param p_data The point of data.
//!
//! @return status - Generic or interface specific status.
//
// ****************************************************************************
static uint32_t tas2560_load_data(uint8_t chip_addr, const uint32_t *p_data)
{
    uint32_t        reg;
    const uint32_t *data;
    uint32_t        offset = 0;
    uint32_t        size   = 0;
    uint32_t        status = AM_DEVICES_TAS2560_STATUS_SUCCESS;

    do
    {
        reg  = p_data[offset];
        size = p_data[offset + 1];
        data = &p_data[offset + 2];
        if (reg == TAS2560_MSLEEP)
        {
            // Currently no operation for sleep
        }
        else if (reg == TAS2560_MDELAY)
        {
            am_util_delay_ms(data[0]);
        }
        else
        {
            if (reg != TAS2560_END)
            {
                if (size > 128)
                {
                    status = AM_DEVICES_TAS2560_STATUS_OUT_OF_RANGE;
                    break;
                }

                if (size >= 1)
                {
                    status = tas2560_bulk_write(chip_addr, reg, (uint8_t *)data,
                                                size);
                    if (status != AM_DEVICES_TAS2560_STATUS_SUCCESS)
                    {
                        break;
                    }
                }
                else
                {
                    status = AM_DEVICES_TAS2560_STATUS_INVALID_ARG;
                }
            }
        }
        offset = offset + 2 + p_data[offset + 1];
    } while (reg != TAS2560_END);

    return status;
}

uint32_t am_devices_tas2560_set_sample_rate(uint8_t  chip_addr,
                                            uint32_t sample_rate)
{
    uint32_t status = AM_DEVICES_TAS2560_STATUS_SUCCESS;

    switch (sample_rate)
    {
        case 48000:
            status = tas2560_load_data(chip_addr, p_tas2560_48khz_data);
            break;

        case 44100:
            status = tas2560_load_data(chip_addr, p_tas2560_441khz_data);
            break;

        case 16000:
            status = tas2560_load_data(chip_addr, p_tas2560_16khz_data);
            break;

        case 8000:
            status = tas2560_load_data(chip_addr, p_tas2560_8khz_data);
            break;

        default:
            status = AM_DEVICES_TAS2560_STATUS_INVALID_ARG;
            break;
    }

    return status;
}

uint32_t am_devices_tas2560_set_channel(uint8_t                 chip_addr,
                                        am_devices_tas2560_ch_t ch)
{
    uint32_t status = AM_DEVICES_TAS2560_STATUS_SUCCESS;
    uint8_t  buf[]  = {0};

    if ((ch > TAS2560_LEFT) || (ch < TAS2560_MONO))
    {
        buf[0] = ch;
        status =
            tas2560_bulk_write(chip_addr, TAS2560_CHANNEL, buf, sizeof(buf));
    }
    else
    {
        status = AM_DEVICES_TAS2560_STATUS_OUT_OF_RANGE;
    }

    return status;
}

uint32_t am_devices_tas2560_set_mute(uint8_t                   chip_addr,
                                     am_devices_tas2560_mute_t val)
{
    uint32_t status = AM_DEVICES_TAS2560_STATUS_SUCCESS;

    switch (val)
    {
        case TAS2560_MUTE:
            status = tas2560_load_data(chip_addr, p_tas2560_mute_data);
            break;

        case TAS2560_UNMUTE:
            status = tas2560_load_data(chip_addr, p_tas2560_unmute_data);
            break;

        default:
            status = AM_DEVICES_TAS2560_STATUS_OUT_OF_RANGE;
            break;
    }

    return status;
}
// ****************************************************************************
//
//  Initialize IOM I2C and DMA
//
// ****************************************************************************
uint32_t am_devices_tas2560_i2c_init(uint32_t             ui32Module,
                                     am_hal_iom_config_t *psIOMSettings)
{
    if (ui32Module > AM_REG_IOM_NUM_MODULES)
    {
        return AM_DEVICES_TAS2560_STATUS_OUT_OF_RANGE;
    }

    if (g_tas2560_IOMHandle != NULL)
    {
        return AM_DEVICES_TAS2560_STATUS_IN_USE;
    }

    //
    // Configure the IOM pins.
    //
    am_bsp_iom_pins_enable(ui32Module, AM_HAL_IOM_I2C_MODE);

    //
    // Initialize the IOM instance.
    // Enable power to the IOM instance.
    // Configure the IOM for Serial operation during initialization.
    // Enable the IOM.
    // HAL Success return is 0
    //
    if (am_hal_iom_initialize(ui32Module, &g_tas2560_IOMHandle) ||
        am_hal_iom_power_ctrl(g_tas2560_IOMHandle, AM_HAL_SYSCTRL_WAKE,
                              false) ||
        am_hal_iom_configure(g_tas2560_IOMHandle, psIOMSettings) ||
        am_hal_iom_enable(g_tas2560_IOMHandle))
    {
        return AM_DEVICES_TAS2560_STATUS_HW_ERR;
    }

    return AM_DEVICES_TAS2560_STATUS_SUCCESS;
}

// ****************************************************************************
//
//  Initialize the TAS2560 chip
//
// ****************************************************************************
uint32_t am_devices_tas2560_init(uint8_t chip_addr)
{
    return tas2560_init_def_params(chip_addr, tas2560_def_params_table,
                                   sizeof(tas2560_def_params_table) /
                                       sizeof(tas2560_def_params_table[0]));
}

// ****************************************************************************
//
//  Deinitialize IOM I2C and DMA
//
// ****************************************************************************
uint32_t am_devices_tas2560_i2c_deinit(uint32_t ui32Module)
{
    if (ui32Module > AM_REG_IOM_NUM_MODULES)
    {
        return AM_DEVICES_TAS2560_STATUS_OUT_OF_RANGE;
    }

    am_bsp_iom_pins_disable(ui32Module, AM_HAL_IOM_I2C_MODE);

    if (g_tas2560_IOMHandle != NULL)
    {
        //
        // Disable the IOM.
        //
        if (am_hal_iom_disable(g_tas2560_IOMHandle) )
        {
            return AM_DEVICES_TAS2560_STATUS_INVALID_HANDLE;
        }

        //
        // Disable power to and uninitialize the IOM instance.
        //
        if (am_hal_iom_power_ctrl(g_tas2560_IOMHandle, AM_HAL_SYSCTRL_DEEPSLEEP, false) )
        {
            return AM_DEVICES_TAS2560_STATUS_HW_ERR;
        }

        if (am_hal_iom_uninitialize(g_tas2560_IOMHandle) )
        {
            return AM_DEVICES_TAS2560_STATUS_FAIL;
        }

        g_tas2560_IOMHandle = NULL;
    }

    return AM_DEVICES_TAS2560_STATUS_SUCCESS;
}

// ****************************************************************************
//
//  Deinitialize the TAS2560 chip
//
// ****************************************************************************
uint32_t am_devices_tas2560_deinit(uint8_t chip_addr)
{
    // TODO
    return AM_DEVICES_TAS2560_STATUS_SUCCESS;
}

//*****************************************************************************
//
// End Doxygen group.
//! @}
//
//*****************************************************************************
