/* TSI 2023.gen */
// -----------------------------------------------------------------------------
// Copyright (c) 2008-23 Think Silicon Single Member PC
// Think Silicon Single Member PC Confidential Proprietary
// -----------------------------------------------------------------------------
//     All Rights reserved - Unpublished -rights reserved under
//         the Copyright laws of the European Union
//
//  This file includes the Confidential information of Think Silicon Single
//  Member PC The receiver of this Confidential Information shall not disclose
//  it to any third party and shall protect its confidentiality by using the
//  same degree of care, but not less then a reasonable degree of care, as the
//  receiver uses to protect receiver's own Confidential Information. The entire
//  notice must be reproduced on all authorized copies and copies may only be
//  made to the extent permitted by a licensing agreement from Think Silicon
//  Single Member PC.
//
//  The software/data is provided 'as is', without warranty of any kind,
//  expressed or implied, including but not limited to the warranties of
//  merchantability, fitness for a particular purpose and noninfringement. In no
//  event shall Think Silicon Single Member PC be liable for any claim, damages
//  or other liability, whether in an action of contract, tort or otherwise,
//  arising from, out of or in connection with the software.
//
//  For further information please contact:
//
//                    Think Silicon Single Member PC
//                    http://www.think-silicon.com
//                    Patras Science Park
//                    Rion Achaias 26504
//                    Greece
// -----------------------------------------------------------------------------

#ifndef TSVG_BUILDER_H
#define TSVG_BUILDER_H

/* Generated by flatcc 0.6.1-dev FlatBuffers schema compiler for C by dvide.com */

#ifndef TSVG_READER_H
#include "tsvg_reader.h"
#endif
#ifndef FLATBUFFERS_COMMON_BUILDER_H
#include "flatbuffers_common_builder.h"
#endif
#include "flatcc/flatcc_prologue.h"
#undef flatbuffers_identifier
#define flatbuffers_identifier "TSVG"
#undef flatbuffers_extension
#define flatbuffers_extension ".tsvg"

#define __PredefinedShape_formal_args , PredefinedShape_enum_t v0
#define __PredefinedShape_call_args , v0
__flatbuffers_build_scalar(flatbuffers_, PredefinedShape, PredefinedShape_enum_t)

static const flatbuffers_voffset_t __Path_required[] = { 0 };
typedef flatbuffers_ref_t Path_ref_t;
static Path_ref_t Path_clone(flatbuffers_builder_t *B, Path_table_t t);
__flatbuffers_build_table(flatbuffers_, Path, 4)

static const flatbuffers_voffset_t __Grad_required[] = { 0 };
typedef flatbuffers_ref_t Grad_ref_t;
static Grad_ref_t Grad_clone(flatbuffers_builder_t *B, Grad_table_t t);
__flatbuffers_build_table(flatbuffers_, Grad, 13)

static const flatbuffers_voffset_t __Paint_required[] = { 0 };
typedef flatbuffers_ref_t Paint_ref_t;
static Paint_ref_t Paint_clone(flatbuffers_builder_t *B, Paint_table_t t);
__flatbuffers_build_table(flatbuffers_, Paint, 5)

static const flatbuffers_voffset_t __Predefined_required[] = { 0 };
typedef flatbuffers_ref_t Predefined_ref_t;
static Predefined_ref_t Predefined_clone(flatbuffers_builder_t *B, Predefined_table_t t);
__flatbuffers_build_table(flatbuffers_, Predefined, 15)

static const flatbuffers_voffset_t __Text_required[] = { 0 };
typedef flatbuffers_ref_t Text_ref_t;
static Text_ref_t Text_clone(flatbuffers_builder_t *B, Text_table_t t);
__flatbuffers_build_table(flatbuffers_, Text, 5)

static const flatbuffers_voffset_t __Stroke_required[] = { 0 };
typedef flatbuffers_ref_t Stroke_ref_t;
static Stroke_ref_t Stroke_clone(flatbuffers_builder_t *B, Stroke_table_t t);
__flatbuffers_build_table(flatbuffers_, Stroke, 3)

static const flatbuffers_voffset_t __Geometry_required[] = { 0 };
typedef flatbuffers_ref_t Geometry_ref_t;
static Geometry_ref_t Geometry_clone(flatbuffers_builder_t *B, Geometry_table_t t);
__flatbuffers_build_table(flatbuffers_, Geometry, 7)

static const flatbuffers_voffset_t __Svg_required[] = { 0 };
typedef flatbuffers_ref_t Svg_ref_t;
static Svg_ref_t Svg_clone(flatbuffers_builder_t *B, Svg_table_t t);
__flatbuffers_build_table(flatbuffers_, Svg, 4)

#define __Path_formal_args , flatbuffers_uint8_vec_ref_t v0, flatbuffers_float_vec_ref_t v1, flatbuffers_float_vec_ref_t v2, flatbuffers_float_vec_ref_t v3
#define __Path_call_args , v0, v1, v2, v3
static inline Path_ref_t Path_create(flatbuffers_builder_t *B __Path_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, Path, Path_file_identifier, Path_type_identifier)

#define __Grad_formal_args ,\
  float v0, float v1, float v2, float v3,\
  float v4, float v5, float v6, uint32_t v7,\
  flatbuffers_float_vec_ref_t v8, flatbuffers_uint32_vec_ref_t v9, flatbuffers_bool_t v10, float v11, flatbuffers_bool_t v12
#define __Grad_call_args ,\
  v0, v1, v2, v3,\
  v4, v5, v6, v7,\
  v8, v9, v10, v11, v12
static inline Grad_ref_t Grad_create(flatbuffers_builder_t *B __Grad_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, Grad, Grad_file_identifier, Grad_type_identifier)

#define __Paint_formal_args ,\
  uint8_t v0, uint32_t v1, Grad_ref_t v2, float v3, float v4
#define __Paint_call_args ,\
  v0, v1, v2, v3, v4
static inline Paint_ref_t Paint_create(flatbuffers_builder_t *B __Paint_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, Paint, Paint_file_identifier, Paint_type_identifier)

#define __Predefined_formal_args ,\
  PredefinedShape_enum_t v0, float v1, float v2, float v3,\
  float v4, float v5, float v6, float v7,\
  float v8, float v9, float v10, float v11,\
  float v12, float v13, flatbuffers_float_vec_ref_t v14
#define __Predefined_call_args ,\
  v0, v1, v2, v3,\
  v4, v5, v6, v7,\
  v8, v9, v10, v11,\
  v12, v13, v14
static inline Predefined_ref_t Predefined_create(flatbuffers_builder_t *B __Predefined_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, Predefined, Predefined_file_identifier, Predefined_type_identifier)

#define __Text_formal_args ,\
  float v0, float v1, float v2, flatbuffers_string_ref_t v3, flatbuffers_float_vec_ref_t v4
#define __Text_call_args ,\
  v0, v1, v2, v3, v4
static inline Text_ref_t Text_create(flatbuffers_builder_t *B __Text_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, Text, Text_file_identifier, Text_type_identifier)

#define __Stroke_formal_args , uint8_t v0, uint8_t v1, float v2
#define __Stroke_call_args , v0, v1, v2
static inline Stroke_ref_t Stroke_create(flatbuffers_builder_t *B __Stroke_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, Stroke, Stroke_file_identifier, Stroke_type_identifier)

#define __Geometry_formal_args ,\
  Path_ref_t v0, Paint_ref_t v1, Paint_ref_t v2, flatbuffers_bool_t v3,\
  Predefined_ref_t v4, Text_ref_t v5, Stroke_ref_t v6
#define __Geometry_call_args ,\
  v0, v1, v2, v3,\
  v4, v5, v6
static inline Geometry_ref_t Geometry_create(flatbuffers_builder_t *B __Geometry_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, Geometry, Geometry_file_identifier, Geometry_type_identifier)

#define __Svg_formal_args , Geometry_vec_ref_t v0, float v1, float v2, flatbuffers_float_vec_ref_t v3
#define __Svg_call_args , v0, v1, v2, v3
static inline Svg_ref_t Svg_create(flatbuffers_builder_t *B __Svg_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, Svg, Svg_file_identifier, Svg_type_identifier)

__flatbuffers_build_vector_field(0, flatbuffers_, Path_seg, flatbuffers_uint8, uint8_t, Path)
__flatbuffers_build_vector_field(1, flatbuffers_, Path_data, flatbuffers_float, float, Path)
__flatbuffers_build_vector_field(2, flatbuffers_, Path_matrix, flatbuffers_float, float, Path)
__flatbuffers_build_vector_field(3, flatbuffers_, Path_bbox, flatbuffers_float, float, Path)

static inline Path_ref_t Path_create(flatbuffers_builder_t *B __Path_formal_args)
{
    if (Path_start(B)
        || Path_seg_add(B, v0)
        || Path_data_add(B, v1)
        || Path_matrix_add(B, v2)
        || Path_bbox_add(B, v3)) {
        return 0;
    }
    return Path_end(B);
}

static Path_ref_t Path_clone(flatbuffers_builder_t *B, Path_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (Path_start(B)
        || Path_seg_pick(B, t)
        || Path_data_pick(B, t)
        || Path_matrix_pick(B, t)
        || Path_bbox_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, Path_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, Grad_x1, flatbuffers_float, float, 4, 4, 0.00000000f, Grad)
__flatbuffers_build_scalar_field(1, flatbuffers_, Grad_y1, flatbuffers_float, float, 4, 4, 0.00000000f, Grad)
__flatbuffers_build_scalar_field(2, flatbuffers_, Grad_x2, flatbuffers_float, float, 4, 4, 0.00000000f, Grad)
__flatbuffers_build_scalar_field(3, flatbuffers_, Grad_y2, flatbuffers_float, float, 4, 4, 0.00000000f, Grad)
__flatbuffers_build_scalar_field(4, flatbuffers_, Grad_cx, flatbuffers_float, float, 4, 4, 0.00000000f, Grad)
__flatbuffers_build_scalar_field(5, flatbuffers_, Grad_cy, flatbuffers_float, float, 4, 4, 0.00000000f, Grad)
__flatbuffers_build_scalar_field(6, flatbuffers_, Grad_r, flatbuffers_float, float, 4, 4, 0.500000000f, Grad)
__flatbuffers_build_scalar_field(7, flatbuffers_, Grad_sampling, flatbuffers_uint32, uint32_t, 4, 4, UINT32_C(0), Grad)
__flatbuffers_build_vector_field(8, flatbuffers_, Grad_stops, flatbuffers_float, float, Grad)
__flatbuffers_build_vector_field(9, flatbuffers_, Grad_stopColors, flatbuffers_uint32, uint32_t, Grad)
__flatbuffers_build_scalar_field(10, flatbuffers_, Grad_isLinear, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(1), Grad)
__flatbuffers_build_scalar_field(11, flatbuffers_, Grad_ry, flatbuffers_float, float, 4, 4, 0.500000000f, Grad)
__flatbuffers_build_scalar_field(12, flatbuffers_, Grad_isUserSpace, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(1), Grad)

static inline Grad_ref_t Grad_create(flatbuffers_builder_t *B __Grad_formal_args)
{
    if (Grad_start(B)
        || Grad_x1_add(B, v0)
        || Grad_y1_add(B, v1)
        || Grad_x2_add(B, v2)
        || Grad_y2_add(B, v3)
        || Grad_cx_add(B, v4)
        || Grad_cy_add(B, v5)
        || Grad_r_add(B, v6)
        || Grad_sampling_add(B, v7)
        || Grad_stops_add(B, v8)
        || Grad_stopColors_add(B, v9)
        || Grad_ry_add(B, v11)
        || Grad_isLinear_add(B, v10)
        || Grad_isUserSpace_add(B, v12)) {
        return 0;
    }
    return Grad_end(B);
}

static Grad_ref_t Grad_clone(flatbuffers_builder_t *B, Grad_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (Grad_start(B)
        || Grad_x1_pick(B, t)
        || Grad_y1_pick(B, t)
        || Grad_x2_pick(B, t)
        || Grad_y2_pick(B, t)
        || Grad_cx_pick(B, t)
        || Grad_cy_pick(B, t)
        || Grad_r_pick(B, t)
        || Grad_sampling_pick(B, t)
        || Grad_stops_pick(B, t)
        || Grad_stopColors_pick(B, t)
        || Grad_ry_pick(B, t)
        || Grad_isLinear_pick(B, t)
        || Grad_isUserSpace_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, Grad_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, Paint_type, flatbuffers_uint8, uint8_t, 1, 1, UINT8_C(0), Paint)
__flatbuffers_build_scalar_field(1, flatbuffers_, Paint_color, flatbuffers_uint32, uint32_t, 4, 4, UINT32_C(4278190080), Paint)
__flatbuffers_build_table_field(2, flatbuffers_, Paint_grad, Grad, Paint)
__flatbuffers_build_scalar_field(3, flatbuffers_, Paint_strokeWidth, flatbuffers_float, float, 4, 4, 1.00000000f, Paint)
__flatbuffers_build_scalar_field(4, flatbuffers_, Paint_opacity, flatbuffers_float, float, 4, 4, 1.00000000f, Paint)

static inline Paint_ref_t Paint_create(flatbuffers_builder_t *B __Paint_formal_args)
{
    if (Paint_start(B)
        || Paint_color_add(B, v1)
        || Paint_grad_add(B, v2)
        || Paint_strokeWidth_add(B, v3)
        || Paint_opacity_add(B, v4)
        || Paint_type_add(B, v0)) {
        return 0;
    }
    return Paint_end(B);
}

static Paint_ref_t Paint_clone(flatbuffers_builder_t *B, Paint_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (Paint_start(B)
        || Paint_color_pick(B, t)
        || Paint_grad_pick(B, t)
        || Paint_strokeWidth_pick(B, t)
        || Paint_opacity_pick(B, t)
        || Paint_type_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, Paint_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, Predefined_shape, PredefinedShape, PredefinedShape_enum_t, 1, 1, UINT8_C(0), Predefined)
__flatbuffers_build_scalar_field(1, flatbuffers_, Predefined_x, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(2, flatbuffers_, Predefined_y, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(3, flatbuffers_, Predefined_x1, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(4, flatbuffers_, Predefined_y1, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(5, flatbuffers_, Predefined_x2, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(6, flatbuffers_, Predefined_y2, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(7, flatbuffers_, Predefined_width, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(8, flatbuffers_, Predefined_height, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(9, flatbuffers_, Predefined_rx, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(10, flatbuffers_, Predefined_ry, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(11, flatbuffers_, Predefined_r, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(12, flatbuffers_, Predefined_cx, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_scalar_field(13, flatbuffers_, Predefined_cy, flatbuffers_float, float, 4, 4, 0.00000000f, Predefined)
__flatbuffers_build_vector_field(14, flatbuffers_, Predefined_matrix, flatbuffers_float, float, Predefined)

static inline Predefined_ref_t Predefined_create(flatbuffers_builder_t *B __Predefined_formal_args)
{
    if (Predefined_start(B)
        || Predefined_x_add(B, v1)
        || Predefined_y_add(B, v2)
        || Predefined_x1_add(B, v3)
        || Predefined_y1_add(B, v4)
        || Predefined_x2_add(B, v5)
        || Predefined_y2_add(B, v6)
        || Predefined_width_add(B, v7)
        || Predefined_height_add(B, v8)
        || Predefined_rx_add(B, v9)
        || Predefined_ry_add(B, v10)
        || Predefined_r_add(B, v11)
        || Predefined_cx_add(B, v12)
        || Predefined_cy_add(B, v13)
        || Predefined_matrix_add(B, v14)
        || Predefined_shape_add(B, v0)) {
        return 0;
    }
    return Predefined_end(B);
}

static Predefined_ref_t Predefined_clone(flatbuffers_builder_t *B, Predefined_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (Predefined_start(B)
        || Predefined_x_pick(B, t)
        || Predefined_y_pick(B, t)
        || Predefined_x1_pick(B, t)
        || Predefined_y1_pick(B, t)
        || Predefined_x2_pick(B, t)
        || Predefined_y2_pick(B, t)
        || Predefined_width_pick(B, t)
        || Predefined_height_pick(B, t)
        || Predefined_rx_pick(B, t)
        || Predefined_ry_pick(B, t)
        || Predefined_r_pick(B, t)
        || Predefined_cx_pick(B, t)
        || Predefined_cy_pick(B, t)
        || Predefined_matrix_pick(B, t)
        || Predefined_shape_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, Predefined_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, Text_x, flatbuffers_float, float, 4, 4, 0.00000000f, Text)
__flatbuffers_build_scalar_field(1, flatbuffers_, Text_y, flatbuffers_float, float, 4, 4, 0.00000000f, Text)
__flatbuffers_build_scalar_field(2, flatbuffers_, Text_size, flatbuffers_float, float, 4, 4, 12.0000000f, Text)
__flatbuffers_build_string_field(3, flatbuffers_, Text_strText, Text)
__flatbuffers_build_vector_field(4, flatbuffers_, Text_matrix, flatbuffers_float, float, Text)

static inline Text_ref_t Text_create(flatbuffers_builder_t *B __Text_formal_args)
{
    if (Text_start(B)
        || Text_x_add(B, v0)
        || Text_y_add(B, v1)
        || Text_size_add(B, v2)
        || Text_strText_add(B, v3)
        || Text_matrix_add(B, v4)) {
        return 0;
    }
    return Text_end(B);
}

static Text_ref_t Text_clone(flatbuffers_builder_t *B, Text_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (Text_start(B)
        || Text_x_pick(B, t)
        || Text_y_pick(B, t)
        || Text_size_pick(B, t)
        || Text_strText_pick(B, t)
        || Text_matrix_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, Text_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, Stroke_join, flatbuffers_uint8, uint8_t, 1, 1, UINT8_C(0), Stroke)
__flatbuffers_build_scalar_field(1, flatbuffers_, Stroke_cap, flatbuffers_uint8, uint8_t, 1, 1, UINT8_C(0), Stroke)
__flatbuffers_build_scalar_field(2, flatbuffers_, Stroke_miterLimit, flatbuffers_float, float, 4, 4, 4.00000000f, Stroke)

static inline Stroke_ref_t Stroke_create(flatbuffers_builder_t *B __Stroke_formal_args)
{
    if (Stroke_start(B)
        || Stroke_miterLimit_add(B, v2)
        || Stroke_join_add(B, v0)
        || Stroke_cap_add(B, v1)) {
        return 0;
    }
    return Stroke_end(B);
}

static Stroke_ref_t Stroke_clone(flatbuffers_builder_t *B, Stroke_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (Stroke_start(B)
        || Stroke_miterLimit_pick(B, t)
        || Stroke_join_pick(B, t)
        || Stroke_cap_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, Stroke_end(B));
}

__flatbuffers_build_table_field(0, flatbuffers_, Geometry_path, Path, Geometry)
__flatbuffers_build_table_field(1, flatbuffers_, Geometry_fillPaint, Paint, Geometry)
__flatbuffers_build_table_field(2, flatbuffers_, Geometry_strokePaint, Paint, Geometry)
__flatbuffers_build_scalar_field(3, flatbuffers_, Geometry_nonzero, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(0), Geometry)
__flatbuffers_build_table_field(4, flatbuffers_, Geometry_predefined, Predefined, Geometry)
__flatbuffers_build_table_field(5, flatbuffers_, Geometry_text, Text, Geometry)
__flatbuffers_build_table_field(6, flatbuffers_, Geometry_stroke, Stroke, Geometry)

static inline Geometry_ref_t Geometry_create(flatbuffers_builder_t *B __Geometry_formal_args)
{
    if (Geometry_start(B)
        || Geometry_path_add(B, v0)
        || Geometry_fillPaint_add(B, v1)
        || Geometry_strokePaint_add(B, v2)
        || Geometry_predefined_add(B, v4)
        || Geometry_text_add(B, v5)
        || Geometry_stroke_add(B, v6)
        || Geometry_nonzero_add(B, v3)) {
        return 0;
    }
    return Geometry_end(B);
}

static Geometry_ref_t Geometry_clone(flatbuffers_builder_t *B, Geometry_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (Geometry_start(B)
        || Geometry_path_pick(B, t)
        || Geometry_fillPaint_pick(B, t)
        || Geometry_strokePaint_pick(B, t)
        || Geometry_predefined_pick(B, t)
        || Geometry_text_pick(B, t)
        || Geometry_stroke_pick(B, t)
        || Geometry_nonzero_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, Geometry_end(B));
}

__flatbuffers_build_table_vector_field(0, flatbuffers_, Svg_geometries, Geometry, Svg)
__flatbuffers_build_scalar_field(1, flatbuffers_, Svg_width, flatbuffers_float, float, 4, 4, 0.00000000f, Svg)
__flatbuffers_build_scalar_field(2, flatbuffers_, Svg_height, flatbuffers_float, float, 4, 4, 0.00000000f, Svg)
__flatbuffers_build_vector_field(3, flatbuffers_, Svg_matrix, flatbuffers_float, float, Svg)

static inline Svg_ref_t Svg_create(flatbuffers_builder_t *B __Svg_formal_args)
{
    if (Svg_start(B)
        || Svg_geometries_add(B, v0)
        || Svg_width_add(B, v1)
        || Svg_height_add(B, v2)
        || Svg_matrix_add(B, v3)) {
        return 0;
    }
    return Svg_end(B);
}

static Svg_ref_t Svg_clone(flatbuffers_builder_t *B, Svg_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (Svg_start(B)
        || Svg_geometries_pick(B, t)
        || Svg_width_pick(B, t)
        || Svg_height_pick(B, t)
        || Svg_matrix_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, Svg_end(B));
}

#include "flatcc/flatcc_epilogue.h"
#endif /* TSVG_BUILDER_H */
